[{"id":0,"href":"/LexicMap/usage/index/","title":"index","parent":"Usage","content":"$ lexicmap index -h Generate an index from FASTA/Q sequences Input: *1. Sequences of each reference genome should be saved in separate FASTA/Q files, with reference identifiers in the file names. 2. Input plain or gzipped FASTA/Q files can be given via positional arguments or the flag -X/--infile-list with a list of input files. Flag -S/--skip-file-check is optional for skipping file checking. 3. Input can also be a directory containing sequence files via the flag -I/--in-dir, with multiple-level sub-directories allowed. A regular expression for matching sequencing files is available via the flag -r/--file-regexp. 4. Some non-isolate assemblies might have extremely large genomes (e.g., GCA_000765055.1, \u0026gt;150 mb). The flag -g/--max-genome is used to skip these input files, and the file list would be written to a file (-G/--big-genomes). Attention: *1) ► You can rename the sequence files for convenience, e.g., GCF_000017205.1.fa.gz, because the genome identifiers in the index and search result would be: the basenames of files with common FASTA/Q file extensions removed, which are extracted via the flag -N/--ref-name-regexp. ► The extracted genome identifiers better be distinct, which will be shown in search results and are used to extract subsequences in the command \u0026#34;lexicmap utils subseq\u0026#34;. 2) ► Unwanted sequences like plasmids can be filtered out by content in FASTA/Q header via regular expressions (-B/--seq-name-filter). Important parameters: --- Genome data (Memory control) --- *1. -b/--batch-size, ► Maximum number of genomes in each batch (maximum: 131072, default: 10000). ► If the number of input files exceeds this number, input files are split into multiple batches and indexes are built for all batches. In the end, seed files are merged, while genome data files are kept unchanged and collected. ► Bigger values increase indexing memory occupation. --- LexicHash mask generation --- 0. -M/--mask-file, ► File with custom masks, which could be exported from an existing index or newly generated by \u0026#34;lexicmap utils masks\u0026#34;. This flag oversides -k/--kmer, -m/--masks, -s/--rand-seed, et al. *1. -k/--kmer, ► K-mer size (maximum: 32, default: 31). ► Bigger values improve the search specificity and do not increase the index size. *2. -m/--masks, ► Number of LexicHash masks (default: 40000). ► Bigger values improve the search sensitivity, increase the index size, and slow down the search speed. 3. -p/--seed-min-prefix, ► Minimum length of shared substrings (anchors) in searching (maximum: 32, default: 15). ► This value is used to remove masks with a prefix of low-complexity and choose k-mers to fill sketching deserts. --- Seeds data (k-mer-value data) --- 1. -c/--chunks, ► Number of seed file chunks (maximum: 128, default: #CPUs). ► Bigger values accelerate the search speed at the cost of a high disk reading load. The maximum number should not exceed the maximum number of open files set by the operating systems. 2. --partitions, ► Number of partitions for indexing each seed file (default: 512). ► Bigger values bring a little higher memory occupation. 512 is a good value with high searching speed, Larger or smaller values would decrease the speed in \u0026#34;lexicmap search\u0026#34;. ► After indexing, \u0026#34;lexicmap utils reindex-seeds\u0026#34; can be used to reindex the seeds data with another value of this flag. 3. --max-open-files, ► Maximum number of open files (default: 512). ► It\u0026#39;s only used in merging indexes of multiple genome batches. Usage: lexicmap index [flags] [-k \u0026lt;k\u0026gt;] [-m \u0026lt;masks\u0026gt;] { -I \u0026lt;seqs dir\u0026gt; | -X \u0026lt;file list\u0026gt;} -O \u0026lt;out dir\u0026gt; Flags: -b, --batch-size int ► Maximum number of genomes in each batch (maximum value: 131072) (default 10000) -G, --big-genomes string ► Out file of skipped files with genomes \u0026gt;= -G/--max-genome -c, --chunks int ► Number of chunks for storing seeds (k-mer-value data) files. (default 16) -r, --file-regexp string ► Regular expression for matching sequence files in -I/--in-dir, case ignored. (default \u0026#34;\\\\.(f[aq](st[aq])?|fna)(.gz)?$\u0026#34;) --force ► Overwrite existing output directory. -h, --help help for index -I, --in-dir string ► Input directory containing FASTA/Q files. Directory and file symlinks are followed. -k, --kmer int ► Maximum k-mer size. K needs to be \u0026lt;= 32. (default 31) -M, --mask-file string ► File of custom masks. This flag oversides -k/--kmer, -m/--masks, -s/--rand-seed, -p/--seed-min-prefix, et al. -m, --masks int ► Number of LexicHash masks. (default 40000) -g, --max-genome int ► Maximum genome size. Extremely large genomes (e.g., non-isolate assemblies from Genbank) will be skipped. (default 15000000) --max-open-files int ► Maximum opened files, used in merging indexes. (default 512) -O, --out-dir string ► Output LexicMap index directory. --partitions int ► Number of partitions for indexing seeds (k-mer-value data) files. (default 512) -s, --rand-seed int ► Rand seed for generating random masks. (default 1) -N, --ref-name-regexp string ► Regular expression (must contains \u0026#34;(\u0026#34; and \u0026#34;)\u0026#34;) for extracting the reference name from the filename. (default \u0026#34;(?i)(.+)\\\\.(f[aq](st[aq])?|fna)(.gz)?$\u0026#34;) --save-seed-pos ► Save seed positions, which can be inspected with \u0026#34;lexicmap utils seed-pos\u0026#34;. --seed-in-desert-dist int ► Distance of k-mers to fill deserts. (default 200) --seed-max-desert int ► Maximum length of sketching deserts. Deserts with seed distance larger than this value will be filled by choosing k-mers roughly every --seed-in-desert-dist bases. (default 900) -p, --seed-min-prefix int ► Minimum length of shared substrings (anchors) in searching. Here, this value is used to remove low-complexity masks and choose k-mers to fill sketching deserts. (default 15) -B, --seq-name-filter strings ► List of regular expressions for filtering out sequences by contents in FASTA/Q header/name, case ignored. -S, --skip-file-check ► Skip input file checking when given files or a file list. Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples See Building an index ","description":"$ lexicmap index -h Generate an index from FASTA/Q sequences Input: *1. Sequences of each reference genome should be saved in separate FASTA/Q files, with reference identifiers in the file names. 2. Input plain or gzipped FASTA/Q files can be given via positional arguments or the flag -X/--infile-list with a list of input files. Flag -S/--skip-file-check is optional for skipping file checking. 3. Input can also be a directory containing sequence files via the flag -I/--in-dir, with multiple-level sub-directories allowed."},{"id":1,"href":"/LexicMap/introduction/","title":"Introduction","parent":"","content":"LexicMap is a sequence alignment tool aiming to efficiently query gene or plasmid sequences against up to millions of prokaryotic genomes.\nFor example, querying a 51.5-kb plasmid in all 2,340,672 Genbank+Refseq prokaryotic genomes takes only 5 minutes and 2 seconds with 13.7 GB RAM and 48 CPUs, with 17,822 genome hits returned. By contrast, BLASTN is unable to run with the same dataset on common servers because it requires \u0026gt;2000 GB RAM. See performance.\nLexicMap uses a modified LexicHash algorithm, which supports variable-length substring matching rather than classical fixed-length k-mers matching, to compute seeds for sequence alignment and uses multiple-level storage for fast and low-memory quering of seeds data. See algorithm overview.\nLexicMap is also very easy to install (a binary file with no dependencies) and use (tutorials and usages).\nPerformance GTDB repr Index information dataset genomes gzip_size db_size indexing_time indexing_RAM GTDB repr 85,205 75 GB 110 GB 1 h 30 m 38 GB Query performance query query_len genome_hits time RAM a MutL gene 1,956 bp 2 3.2 s 436 MB a 16S rRNA gene 1,542 bp 4,374 38.5 s 747 MB a plasmid 51,466 bp 0 13.0 s 768 MB GTDB complete Index information dataset genomes gzip_size db_size indexing_time indexing_RAM GTDB complete 402,538 578 GB 510 GB 3 h 26 m 35 GB Query performance query query_len genome_hits time RAM a MutL gene 1,956 bp 268 2.8 s 571 MB a 16S rRNA gene 1,542 bp 107,557 3 m 38 s 2.6 GB a plasmid 51,466 bp 3,220 56.2 s 3.0 GB Genbank\u0026#43;RefSeq Index information dataset genomes gzip_size db_size indexing_time indexing_RAM Genbank+RefSeq 2,340,672 3.5 TB 2.91 TB 16 h 40 m 79 GB Query performance query query_len genome_hits time RAM a MutL gene 1,956 bp 817 6.0 s 1.4 GB a 16S rRNA gene 1,542 bp 832,161 18 m 58 s 8.3 GB a plasmid 51,466 bp 17,822 5 m 02 s 13.7 GB AllTheBacteria HQ Index information dataset genomes gzip_size db_size indexing_time indexing_RAM AllTheBacteria HQ 1,858,610 3.1 TB 2.32 TB 10 h 48 m 43 GB Query performance query query_len genome_hits time RAM a MutL gene 1,956 bp 404 4.7 s 1.1 GB a 16S rRNA gene 1,542 bp 1,031,705 17 m 54 s 8.4 GB a plasmid 51,466 bp 10,897 4 m 07 s 10.8 GB Notes:\nAll files are stored on a server with HDD disks. No files are cached in memory. Tests are performed in a single cluster node with 48 CPU cores (Intel Xeon Gold 6336Y CPU @ 2.40 GHz). Index building parameters: -k 31 -m 40000. Genome batch size: -b 10000 for GTDB datasets, -b 50000 for others. Algorithm overview Related projects High-performance LexicHash computation in Go. Support Please open an issue to report bugs, propose new functions or ask for help.\nLicense MIT License\n","description":"LexicMap is a sequence alignment tool aiming to efficiently query gene or plasmid sequences against up to millions of prokaryotic genomes.\nFor example, querying a 51.5-kb plasmid in all 2,340,672 Genbank+Refseq prokaryotic genomes takes only 5 minutes and 2 seconds with 13.7 GB RAM and 48 CPUs, with 17,822 genome hits returned. By contrast, BLASTN is unable to run with the same dataset on common servers because it requires \u0026gt;2000 GB RAM."},{"id":2,"href":"/LexicMap/usage/utils/kmers/","title":"kmers","parent":"utils","content":"$ lexicmap utils kmers -h View k-mers captured by the masks Attentions: 1. Mask index (column mask) is 1-based. 2. K-mer positions (column pos) are 1-based. For reference genomes with multiple sequences, the sequences were concatenated to a single sequence with intervals of N\u0026#39;s. Usage: lexicmap utils kmers [flags] -d \u0026lt;index path\u0026gt; [-m \u0026lt;mask index\u0026gt;] [-o out.tsv.gz] Flags: -h, --help help for kmers -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -m, --mask int ► View k-mers captured by Xth mask. (0 for all) (default 1) -o, --out-file string ► Out file, supports and recommends a \u0026#34;.gz\u0026#34; suffix (\u0026#34;-\u0026#34; for stdout). (default \u0026#34;-\u0026#34;) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16 Examples The default output is captured k-mers of the first mask.\n$ lexicmap utils kmers --quiet -d demo.lmi/ | csvtk pretty -t mask kmer number ref pos strand ---- ------------------------------- ------ --------------- ------- ------ 1 AAAACACATGCTTTCACTGACTTGGAATGCA 1 GCF_001457655.1 389653 + 1 AAAACACATGGATTGTTAAAAGGTAGTTGGC 1 GCF_900638025.1 2061446 - 1 AAAACACATGTAAGCCCCAACCAGGCGGCTT 1 GCF_000742135.1 2569538 - 1 AAAACACATGTCTAAAATTATCGGTATTGAC 2 GCF_000148585.2 326139 + 1 AAAACACATGTCTAAAATTATCGGTATTGAC 2 GCF_001096185.1 34675 - 1 AAAACACATGTGAGGCAGGCGCTCGCCTGTC 1 GCF_001544255.1 938768 - 1 AAAACACATGTGCAAATCCATATGTGTTTAG 1 GCF_002950215.1 2793719 + 1 AAAACACATGTGTTGTTTAAATCAAATTATG 1 GCF_001027105.1 1413381 + 1 AAAACACATGTGTTTAATCACCTTAATTCAA 1 GCF_006742205.1 729899 + 1 AAAACACATGTTCACGGCGGCAGGCTGCAAT 1 GCF_003697165.2 1581455 + 1 AAAACACATGTTCTCAATACTCGCCTGACGC 1 GCF_000006945.2 1274137 - 1 AAAACACATGTTGATCATCATAAATACAGCG 1 GCF_002949675.1 3925773 - 1 AAAACACATGTTGATCTATTCTTATAGCTCA 1 GCF_009759685.1 3295037 - 1 AAAACACATGTTTCAAACATTTTAGCAAAAC 1 GCF_000392875.1 2491283 - 1 AAAACACATGTTTCACACAACTTCACCCAAT 1 GCF_000017205.1 4394137 + Specify the mask.\n$ lexicmap utils kmers --quiet -d demo.lmi/ --mask 12345 | csvtk pretty -t mask kmer number ref pos strand ----- ------------------------------- ------ --------------- ------- ------ 12345 CATGTTATAGAAGGACGTCGACATCTTGTGG 1 GCF_000017205.1 3140677 + 12345 CATGTTATAGAATTACATACATTGTAACATG 1 GCF_006742205.1 704431 - 12345 CATGTTATAGCACGCTTAATCGCTTGATCCC 1 GCF_001027105.1 2655846 + 12345 CATGTTATAGCATCCTTTTACGTGAAAAGGT 1 GCF_000742135.1 4136093 + 12345 CATGTTATAGCCAGCAAATGGAAGCATCGCG 1 GCF_009759685.1 492828 - 12345 CATGTTATAGCCATTGATGGTAACTTTGATG 1 GCF_001096185.1 536843 + 12345 CATGTTATAGCCTGAAAGGTGCTAAACAACT 1 GCF_000006945.2 4876155 + 12345 CATGTTATAGCCTTCTCCAAGACCAATCAAA 1 GCF_000148585.2 1667015 + 12345 CATGTTATAGCGTAAATCAGCACCGCGCGCC 3 GCF_003697165.2 3996124 + 12345 CATGTTATAGCGTAAATCAGCACCGCGCGCC 3 GCF_002949675.1 1871326 + 12345 CATGTTATAGCGTAAATCAGCACCGCGCGCC 3 GCF_002950215.1 2326544 + 12345 CATGTTATAGCTAACTGCGACTTGTGGCACA 1 GCF_900638025.1 991007 - 12345 CATGTTATAGTAAACAAAAGTAGTGACGAAT 1 GCF_000392875.1 1539455 - 12345 CATGTTATAGTCGTGAGGTTCTAAAAAAACT 1 GCF_001544255.1 1091256 - 12345 CATGTTATATGAACCTTCAACCTTATTTGAC 1 GCF_001457655.1 1510084 + For all masks. The result might be very big, therefore, writing to gzip format is recommended.\n$ lexicmap utils kmers --quiet -d demo.lmi/ --mask 0 -o kmers.tsv.gz The output (TSV format) is formatted with csvtk pretty.\n","description":"$ lexicmap utils kmers -h View k-mers captured by the masks Attentions: 1. Mask index (column mask) is 1-based. 2. K-mer positions (column pos) are 1-based. For reference genomes with multiple sequences, the sequences were concatenated to a single sequence with intervals of N\u0026#39;s. Usage: lexicmap utils kmers [flags] -d \u0026lt;index path\u0026gt; [-m \u0026lt;mask index\u0026gt;] [-o out.tsv.gz] Flags: -h, --help help for kmers -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;."},{"id":3,"href":"/LexicMap/quick-start/","title":"Quick start","parent":"","content":"Installing LexicMap (see installation).\nconda install -c bioconda lexicmap Building an index (see the tutorial of building an index).\n# From a directory with multiple genome files lexicmap index -I genomes/ -O db.lmi # From a file list with one file per line lexicmap index -X files.txt -O db.lmi Querying (see the tutorial of searching).\n# For short queries like genes or long reads, returning top N hits. lexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 70 --min-match-pident 70 --min-qcov-per-hsp 70 --top-n-genomes 1000 # For longer queries like plasmids, returning all hits. lexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 50 --min-match-pident 70 --min-qcov-per-hsp 0 --top-n-genomes 0 Sample output (queries are a few Nanopore Q20 reads). See output format details.\nquery qlen qstart qend hits sgenome sseqid qcovGnm hsp qcovHSP alenHSP alenSeg pident slen sstart send sstr seeds species ------------------ ---- ------ ---- ---- --------------- ----------------- ------- --- ------- ------- ------- ------- ------- ------- ------- ---- ----- ----------------------------- ERR5396170.1000017 516 27 514 1 GCF_013394085.1 NZ_CP040910.1 94.574 1 94.574 488 488 100.000 1887974 293509 293996 + 3 Limosilactobacillus fermentum ERR5396170.1000047 960 24 812 1 GCF_001027105.1 NZ_CP011526.1 90.521 1 90.521 869 789 89.480 2755072 2204718 2205520 - 6 Staphylococcus aureus ERR5396170.1000047 960 881 960 1 GCF_001027105.1 NZ_CP011526.1 90.521 1 90.521 869 80 100.000 2755072 2204568 2204647 - 6 Staphylococcus aureus ERR5396170.1000016 740 71 733 1 GCF_013394085.1 NZ_CP040910.1 89.595 1 89.595 663 663 98.492 1887974 13515 14177 + 12 Limosilactobacillus fermentum ERR5396170.1000000 698 53 650 1 GCF_001457615.1 NZ_LN831024.1 85.673 1 85.673 598 598 97.324 6316979 4452083 4452685 + 4 Pseudomonas aeruginosa ERR5396170.1000005 2516 38 2510 5 GCF_000006945.2 NC_003197.2 98.291 1 98.291 2473 2473 99.151 4857450 3198806 3201283 + 15 Salmonella enterica ERR5396170.1000005 2516 38 2497 5 GCF_008692785.1 NZ_VXJV01000001.1 97.774 1 97.774 2460 2460 96.098 797633 423400 425865 + 14 Salmonella enterica ERR5396170.1000005 2516 40 2510 5 GCA_900478215.1 LS483478.1 98.211 1 98.211 2471 2471 95.548 4624613 785866 788342 - 13 Salmonella enterica ERR5396170.1000005 2516 1350 2497 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 1148 95.557 366711 6705 7855 + 12 Salmonella enterica ERR5396170.1000005 2516 634 1309 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 676 89.053 366711 5991 6664 + 12 Salmonella enterica ERR5396170.1000005 2516 387 608 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 222 85.135 366711 5745 5965 + 12 Salmonella enterica ERR5396170.1000005 2516 69 205 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 137 83.212 366711 5426 5563 + 12 Salmonella enterica ERR5396170.1000005 2516 1830 2263 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 434 97.696 4460105 2898281 2898717 + 7 Salmonella bongori ERR5396170.1000005 2516 2307 2497 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 191 76.963 4460105 2898761 2898951 + 7 Salmonella bongori ERR5396170.1000005 2516 415 938 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 524 86.641 4460105 2896865 2897391 + 7 Salmonella bongori ERR5396170.1000005 2516 1113 1807 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 695 71.511 4460105 2897564 2898258 + 7 Salmonella bongori ERR5396170.1000005 2516 961 1088 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 128 85.156 4460105 2897414 2897541 + 7 Salmonella bongori Note: the column `species` is added by mapping genome ID (column `sgenome`) to taxonomic information. Learn more tutorials and usages.\n","description":"Installing LexicMap (see installation).\nconda install -c bioconda lexicmap Building an index (see the tutorial of building an index).\n# From a directory with multiple genome files lexicmap index -I genomes/ -O db.lmi # From a file list with one file per line lexicmap index -X files.txt -O db.lmi Querying (see the tutorial of searching).\n# For short queries like genes or long reads, returning top N hits. lexicmap search -d db."},{"id":4,"href":"/LexicMap/tutorials/search/","title":"Searching","parent":"Tutorials","content":" Table of contents Table of contents TL;DR Input Hardware requirements Algorithm Parameters Steps Output Alignment result relationship Output format Examples TL;DR Build or download a LexicMap index.\nRun:\nFor short queries like genes or long reads, returning top N hits.\nlexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 70 --min-match-pident 70 --min-qcov-per-hsp 70 --top-n-genomes 1000 For longer queries like plasmids, returning all hits.\nlexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 50 --min-match-pident 70 --min-qcov-per-hsp 0 --top-n-genomes 0 Input Query length\nLexicMap only supports long (\u0026gt;=500 bp) reads or gene/genome/virus/plasmid/phage sequences.\nHowever, some short queries can also be aligned. Input should be (gzipped) FASTA or FASTQ records from files or STDIN.\nHardware requirements LexicMap is designed to provide fast and low-memory sequence alignment against millions of prokaryotic genomes.\nCPU: No specific requirements on CPU type and instruction sets. Both x86 and ARM chips are supported. More is better as LexicMap is a CPU-intensive software. It uses all CPUs by default (-j/--threads). RAM More RAM (\u0026gt; 16 GB) is preferred. The memory usage in searching is mainly related to: The number of matched genomes and sequences. The length of query sequences. Disk Sufficient space is required to store the index size. No temporary files are generated during searching. Algorithm Masking: Query sequence is masked by the masks of the index. In other word, each mask captures the most similar k-mer which shares the longest prefix with the mask, and stores its posistion and strand information. Seeding: For each mask, the captured k-mer is used to search seeds (captured k-mers in reference genomes) sharing prefixes of at least p bases. Setting the search range: Since the seeded k-mers are stored in lexicographic order, the k-mer matching turns into a range query. For example, for a query CATGCT requiring matching at least 4-bp prefix is equal to extract k-mers ranging from CATGAA, CATGAC, CATGAG, \u0026hellip;, to CATGTT. Finding the nearest offset: The index file of each seed data file stores a list (default 512) of k-mers and offsets in the data file, and the index is Loaded in RAM. The nearest k-mer smaller than the range start k-mer (CATGAA) is found by binary search, i.e., CATCAC (blue text in the fingure), and the offset is returned as the start position in traversing the seed data file. Retrieving seed data: Seed k-mers are read from the file and checked one by one, and k-mers in the search range are returned, along with the k-mer information (genome batch, genome number, location, and strand). Chaining: Seeding results, i.e., anchors (matched k-mers from the query and subject sequence), are summarized by genome, and deduplicated. Performing chaining. Alignment for each chain. Extending the anchor region. for extracting sequences from the query and reference genome. For example, extending 2 kb in upstream and downstream of anchor region. Fast alignment of query and subject sequences. Filtering aligned segments and the whole HSPs (all alignment segments) based on user options. For these HSPs that accross more than one reference sequences, splitting them into multiple HSPs. Parameters Flags in bold text are important and frequently used.\nGeneral Flag Value Function Comment -w/--load-whole-seeds Load the whole seed data into memory for faster search Use this if the index is not big and many queries are needed to search. -n/--top-n-genomes Default 500, 0 for all Keep top N genome matches for a query Chaining Flag Value Function Comment -p, --seed-min-prefix Default 15 Minimum length of shared substrings (anchors). -P, --seed-min-single-prefix Default 20 Minimum length of shared substrings (anchors) if there\u0026rsquo;s only one pair. --seed-max-dist Default 10000 Max distance between seeds in seed chaining. --seed-max-gap Default 2000 Max gap in seed chaining. -m/--seed-max-mismatch Default -1 Minimum mismatch between non-prefix regions of shared substrings. Alignment Flag Value Function Comment -Q/--min-qcov-per-genome Default 50 Minimum query coverage (percentage) per genome. -q/--min-qcov-per-hsp Default 0 Minimum query coverage (percentage) per HSP. -l/--align-min-match-len Default 50 Minimum aligned length in a HSP segment. -i/--align-min-match-pident Default 70 Minimum base identity (percentage) in a HSP segment. --align-band Default 100 Band size in backtracking the score matrix. --align-ext-len Default 2000 Extend length of upstream and downstream of seed regions, for extracting query and target sequences for alignment. --align-max-gap Default 50 Maximum gap in a HSP segment. --align-max-mismatch Default 50 Maximum mismatch in a HSP segment. Steps For short queries like genes or long reads, returning top N hits.\nlexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 70 \\ --min-match-pident 70 \\ --min-qcov-per-hsp 70 \\ --top-n-genomes 500 For longer queries like plasmids, returning all hits.\nlexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 50 \\ --min-match-pident 70 \\ --min-qcov-per-hsp 0 \\ --top-n-genomes 0 Click to show the log of a demo run. ... $ lexicmap search -d demo.lmi/ q.gene.fasta -o q.gene.fasta.lexicmap.tsv 09:32:55.551 [INFO] LexicProf v0.3.0 09:32:55.551 [INFO] https://github.com/shenwei356/LexicMap 09:32:55.551 [INFO] 09:32:55.551 [INFO] checking input files ... 09:32:55.551 [INFO] 1 input file(s) given 09:32:55.551 [INFO] 09:32:55.551 [INFO] loading index: demo.lmi/ 09:32:55.551 [INFO] reading masks... 09:32:55.552 [INFO] reading indexes of seeds (k-mer-value) data... 09:32:55.555 [INFO] creating genome reader pools, each batch with 16 readers... 09:32:55.555 [INFO] index loaded in 4.192051ms 09:32:55.555 [INFO] 09:32:55.555 [INFO] searching ... 09:32:55.596 [INFO] 09:32:55.596 [INFO] processed queries: 1, speed: 1467.452 queries per minute 09:32:55.596 [INFO] 100.0000% (1/1) queries matched 09:32:55.596 [INFO] done searching 09:32:55.596 [INFO] search results saved to: q.gene.fasta.lexicmap.tsv 09:32:55.596 [INFO] 09:32:55.596 [INFO] elapsed time: 45.230604ms 09:32:55.596 [INFO] Output Alignment result relationship Query ├── Subject genome # A query might have one or more genome hits, ├── Subject sequence # in different sequences. ├── High-Scoring segment Pairs (HSP) # HSP is a cluster of alignment segments. ├── HSP segment # A local alignment with no gaps. Here, the defination of HSP is slightly different from that in BLAST.\nA High-scoring Segment Pair (HSP) is a local alignment with no gaps that achieves one of the highest alignment scores in a given search. https://www.ncbi.nlm.nih.gov/books/NBK62051/\nOutput format Tab-delimited format with 18 columns. (The positions are 1-based).\n1. query, Query sequence ID. 2. qlen, Query sequence length. 3. qstart, Start of alignment in query sequence. 4. qend, End of alignment in query sequence. 5. hits, The number of Subject genomes. 6. sgenome, Subject genome ID. 7. seqid, Subject sequence ID. 8. qcovGnm, Query coverage (percentage) per genome: $(aligned bases in the genome)/$qlen. 9. hsp, Nth HSP in the genome. 10. qcovHSP Query coverage (percentage) per HSP: $(aligned bases in a HSP)/$qlen. 11. alen, Aligned length in the current HSP, a HSP might have \u0026gt;=1 HSP segments. 12. alenSeg, Aligned length in the current HSP segment. 13. pident, Percentage of identical matches in the current HSP segment. 14. slen, Subject sequence length. 15. sstart, Start of HSP segment in subject sequence. 16. send, End of HSP segment in subject sequence. 17. sstr, Subject strand. 18. seeds, Number of seeds in the current HSP. Examples A 16S rRNA gene The (part) result shows the 16S rRNA gene has 8 genome hits (column sgenome). And in genome GCF_003697165.2, it has 7 highly similar matches with query coverage per HSP (column qcovHSP) of 100% and percentage of identity (pident) \u0026gt; 99%. It makes sense as 16S rRNA genes might have multiple copies in a genome.\nquery qlen qstart qend hits sgenome sseqid qcovGnm hsp qcovHSP alenHSP alenSeg pident slen sstart send sstr seeds --------------------------- ---- ------ ---- ---- --------------- ------------- ------- --- ------- ------- ------- ------ ------- ------- ------- ---- ----- NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 1 100.000 1542 1542 99.287 4903501 4844587 4846128 - 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 2 100.000 1542 1542 99.287 4903501 4591684 4593225 - 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 3 100.000 1542 1542 99.287 4903501 4551515 4553056 - 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 4 100.000 1542 1542 99.287 4903501 3780640 3782181 - 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 5 100.000 1542 1542 99.287 4903501 458559 460100 + 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 6 100.000 1542 1542 99.287 4903501 1285123 1286664 + 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_003697165.2 NZ_CP033092.2 100.000 7 100.000 1542 1542 99.092 4903501 4726193 4727734 - 26 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_002950215.1 NZ_CP026788.1 100.000 1 100.000 1542 1542 99.027 4659463 3216505 3218046 + 25 NC_000913.3:4166659-4168200 1542 1 1542 8 GCF_002950215.1 NZ_CP026788.1 100.000 2 100.000 1542 1542 98.962 4659463 3396068 3397609 + 26 A plasmid This plasmid has 17,716 genome hits in the index (2.34 millions prokaryotic genome from Genbank and RefSeq).\nquery qlen qstart qend hits sgenome sseqid qcovGnm hsp qcovHSP alenHSP alenSeg pident slen sstart send sstr seeds ------- ----- ------ ----- ----- --------------- -------------------- ------- --- ------- ------- ------- ------- ------- ------- ------- ---- ----- plasmid 51466 1 50164 17716 GCA_032192075.1 JAVTRN010000003.1 100.000 1 100.000 51466 50164 100.000 51479 1303 51479 + 487 plasmid 51466 50165 51466 17716 GCA_032192075.1 JAVTRN010000003.1 100.000 1 100.000 51466 1302 100.000 51479 1 1302 + 487 plasmid 51466 18302 18401 17716 GCA_032192075.1 JAVTRN010000003.1 100.000 2 0.194 100 100 100.000 51479 25698 25797 - 2 plasmid 51466 34042 34125 17716 GCA_032192075.1 JAVTRN010000003.1 100.000 3 0.163 84 84 89.286 51479 45852 45935 + 1 plasmid 51466 1 50164 17716 GCF_032192075.1 NZ_JAVTRN010000003.1 100.000 1 100.000 51466 50164 100.000 51479 1303 51479 + 487 plasmid 51466 50165 51466 17716 GCF_032192075.1 NZ_JAVTRN010000003.1 100.000 1 100.000 51466 1302 100.000 51479 1 1302 + 487 plasmid 51466 18302 18401 17716 GCF_032192075.1 NZ_JAVTRN010000003.1 100.000 2 0.194 100 100 100.000 51479 25698 25797 - 2 plasmid 51466 34042 34125 17716 GCF_032192075.1 NZ_JAVTRN010000003.1 100.000 3 0.163 84 84 89.286 51479 45852 45935 + 1 plasmid 51466 1 50164 17716 GCA_030863645.1 CP114982.1 100.000 1 100.000 51466 50164 99.994 51479 1303 51479 + 530 plasmid 51466 50165 51466 17716 GCA_030863645.1 CP114982.1 100.000 1 100.000 51466 1302 100.000 51479 1 1302 + 530 plasmid 51466 27858 29180 17716 GCA_030863645.1 CP114979.1 100.000 2 2.571 1323 1323 100.000 4731337 1893701 1895023 - 12 plasmid 51466 43101 43921 17716 GCA_030863645.1 CP114980.1 100.000 3 1.595 821 821 100.000 165063 42818 43638 - 5 plasmid 51466 43100 43920 17716 GCA_030863645.1 CP114980.1 100.000 4 1.595 821 821 100.000 165063 50985 51805 - 5 plasmid 51466 43101 43920 17716 GCA_030863645.1 CP114981.1 100.000 5 1.593 820 820 100.000 82723 55698 56517 + 5 plasmid 51466 43101 43920 17716 GCA_030863645.1 CP114980.1 100.000 6 1.593 820 820 100.000 165063 153475 154294 - 5 plasmid 51466 43101 43920 17716 GCA_030863645.1 CP114980.1 100.000 7 1.593 820 820 100.000 165063 160027 160846 - 5 plasmid 51466 43101 43452 17716 GCA_030863645.1 CP114980.1 100.000 7 1.593 820 352 99.716 165063 158276 158627 - 5 plasmid 51466 43101 43920 17716 GCA_030863645.1 CP114980.1 100.000 8 1.593 820 820 100.000 165063 145617 146436 + 5 plasmid 51466 43101 43920 17716 GCA_030863645.1 CP114980.1 100.000 9 1.593 820 820 99.878 165063 157808 158627 - 4 plasmid 51466 43555 43920 17716 GCA_030863645.1 CP114980.1 100.000 9 1.593 820 366 100.000 165063 160027 160392 - 4 plasmid 51466 29790 30607 17716 GCA_030863645.1 CP114980.1 100.000 10 1.589 818 818 98.778 165063 42819 43639 - 5 plasmid 51466 29791 30608 17716 GCA_030863645.1 CP114980.1 100.000 11 1.589 818 818 98.778 165063 50984 51804 - 5 plasmid 51466 29791 30608 17716 GCA_030863645.1 CP114980.1 100.000 12 1.589 818 818 98.778 165063 145617 146437 + 5 plasmid 51466 29790 30607 17716 GCA_030863645.1 CP114981.1 100.000 13 1.589 818 818 98.778 82723 55697 56517 + 5 plasmid 51466 29791 30608 17716 GCA_030863645.1 CP114980.1 100.000 14 1.589 818 818 98.778 165063 160026 160846 - 5 plasmid 51466 29791 30142 17716 GCA_030863645.1 CP114980.1 100.000 14 1.589 818 352 99.148 165063 158276 158627 - 5 plasmid 51466 29791 30608 17716 GCA_030863645.1 CP114980.1 100.000 15 1.589 818 818 98.778 165063 153474 154294 - 5 plasmid 51466 29791 30609 17716 GCA_030863645.1 CP114980.1 100.000 16 1.591 819 819 98.657 165063 157806 158627 - 4 plasmid 51466 30242 30608 17716 GCA_030863645.1 CP114980.1 100.000 16 1.591 819 367 100.000 165063 160026 160392 - 4 plasmid 51466 29791 30607 17716 GCA_030863645.1 CP114982.1 100.000 17 1.587 817 817 98.776 51479 44415 45234 + 5 plasmid 51466 29791 30607 17716 GCA_030863645.1 CP114980.1 100.000 18 1.587 817 817 98.776 165063 31910 32729 + 5 plasmid 51466 18302 18401 17716 GCA_030863645.1 CP114982.1 100.000 19 0.194 100 100 100.000 51479 25698 25797 - 2 plasmid 51466 44536 44622 17716 GCA_030863645.1 CP114981.1 100.000 20 0.169 87 87 87.356 82723 49696 49782 + 1 plasmid 51466 34042 34125 17716 GCA_030863645.1 CP114982.1 100.000 21 0.163 84 84 89.286 51479 45852 45935 + 1 plasmid 51466 34042 34125 17716 GCA_030863645.1 CP114981.1 100.000 22 0.163 84 84 86.905 82723 49698 49781 + 1 Long reads Queries are a few Nanopore Q20 reads from a mock metagenomic community.\nquery qlen qstart qend hits sgenome sseqid qcovGnm hsp qcovHSP alenHSP alenSeg pident slen sstart send sstr seeds ------------------ ---- ------ ---- ---- --------------- ----------------- ------- --- ------- ------- ------- ------- ------- ------- ------- ---- ----- ERR5396170.1000017 516 27 514 1 GCF_013394085.1 NZ_CP040910.1 94.574 1 94.574 488 488 100.000 1887974 293509 293996 + 3 ERR5396170.1000047 960 24 812 1 GCF_001027105.1 NZ_CP011526.1 90.521 1 90.521 869 789 89.480 2755072 2204718 2205520 - 6 ERR5396170.1000047 960 881 960 1 GCF_001027105.1 NZ_CP011526.1 90.521 1 90.521 869 80 100.000 2755072 2204568 2204647 - 6 ERR5396170.1000016 740 71 733 1 GCF_013394085.1 NZ_CP040910.1 89.595 1 89.595 663 663 98.492 1887974 13515 14177 + 12 ERR5396170.1000000 698 53 650 1 GCF_001457615.1 NZ_LN831024.1 85.673 1 85.673 598 598 97.324 6316979 4452083 4452685 + 4 ERR5396170.1000005 2516 38 2510 5 GCF_000006945.2 NC_003197.2 98.291 1 98.291 2473 2473 99.151 4857450 3198806 3201283 + 15 ERR5396170.1000005 2516 38 2497 5 GCF_008692785.1 NZ_VXJV01000001.1 97.774 1 97.774 2460 2460 96.098 797633 423400 425865 + 14 ERR5396170.1000005 2516 40 2510 5 GCA_900478215.1 LS483478.1 98.211 1 98.211 2471 2471 95.548 4624613 785866 788342 - 13 ERR5396170.1000005 2516 1350 2497 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 1148 95.557 366711 6705 7855 + 12 ERR5396170.1000005 2516 634 1309 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 676 89.053 366711 5991 6664 + 12 ERR5396170.1000005 2516 387 608 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 222 85.135 366711 5745 5965 + 12 ERR5396170.1000005 2516 69 205 5 GCF_008692845.1 NZ_VXJW01000004.1 86.765 1 86.765 2183 137 83.212 366711 5426 5563 + 12 ERR5396170.1000005 2516 1830 2263 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 434 97.696 4460105 2898281 2898717 + 7 ERR5396170.1000005 2516 2307 2497 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 191 76.963 4460105 2898761 2898951 + 7 ERR5396170.1000005 2516 415 938 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 524 86.641 4460105 2896865 2897391 + 7 ERR5396170.1000005 2516 1113 1807 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 695 71.511 4460105 2897564 2898258 + 7 ERR5396170.1000005 2516 961 1088 5 GCF_000252995.1 NC_015761.1 78.378 1 78.378 1972 128 85.156 4460105 2897414 2897541 + 7 Search results (TSV format) above are formatted with csvtk pretty.\n","description":"Table of contents Table of contents TL;DR Input Hardware requirements Algorithm Parameters Steps Output Alignment result relationship Output format Examples TL;DR Build or download a LexicMap index.\nRun:\nFor short queries like genes or long reads, returning top N hits.\nlexicmap search -d db.lmi query.fasta -o query.fasta.lexicmap.tsv \\ --min-qcov-per-genome 70 --min-match-pident 70 --min-qcov-per-hsp 70 --top-n-genomes 1000 For longer queries like plasmids, returning all hits.\nlexicmap search -d db.lmi query.fasta -o query."},{"id":5,"href":"/LexicMap/installation/","title":"Installation","parent":"","content":"LexicMap can be installed via conda, executable binary files, or compiling from the source.\nBesides, it supports shell completion, which could help accelerate typing.\nConda Install conda, then run\nconda install -c bioconda lexicmap Binary files Linux Download the binary file.\nOS Arch File, 中国镜像 Linux 64-bit lexicmap_linux_amd64.tar.gz, 中国镜像 Linux arm64 lexicmap_linux_arm64.tar.gz, 中国镜像 Decompress it\ntar -zxvf lexicmap_linux_amd64.tar.gz If you have the root privilege, simply copy it to /usr/local/bin:\nsudo cp lexicmap /usr/local/bin/ Or copy to anywhere in the environment variable PATH:\nmkdir -p $HOME/bin/; cp lexicmap $HOME/bin/ MacOS Download the binary file. OS Arch File, 中国镜像 macOS 64-bit lexicmap_darwin_amd64.tar.gz, 中国镜像 macOS arm64 lexicmap_darwin_arm64.tar.gz, 中国镜像 Windows Download the binary file.\nOS Arch File, 中国镜像 Windows 64-bit lexicmap_windows_amd64.exe.tar.gz, 中国镜像 Decompress it.\nCopy lexicmap.exe to C:\\WINDOWS\\system32.\nOthers Please open an issue to request binaries for other platforms. Or compiling from the source. Compile from the source Install go.\nwget https://go.dev/dl/go1.22.2.linux-amd64.tar.gz tar -zxf go1.22.2.linux-amd64.tar.gz -C $HOME/ # or # echo \u0026quot;export PATH=$PATH:$HOME/go/bin\u0026quot; \u0026gt;\u0026gt; ~/.bashrc # source ~/.bashrc export PATH=$PATH:$HOME/go/bin Compile LexicMap.\n# ------------- the latest stable version ------------- go get -v -u github.com/shenwei356/LexicMap/lexicmap # The executable binary file is located in: # ~/go/bin/lexicmap # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ~/go/bin/lexicmap $HOME/bin/ # --------------- the development version -------------- git clone https://github.com/shenwei356/LexicMap cd LexicMap/lexicmap/ go build # The executable binary file is located in: # ./lexicmap # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ./lexicmap $HOME/bin/ Shell-completion Supported shell: bash|zsh|fish|powershell\nBash:\n# generate completion shell lexicmap autocompletion --shell bash # configure if never did. # install bash-completion if the \u0026quot;complete\u0026quot; command is not found. echo \u0026quot;for bcfile in ~/.bash_completion.d/* ; do source \\$bcfile; done\u0026quot; \u0026gt;\u0026gt; ~/.bash_completion echo \u0026quot;source ~/.bash_completion\u0026quot; \u0026gt;\u0026gt; ~/.bashrc Zsh:\n# generate completion shell lexicmap autocompletion --shell zsh --file ~/.zfunc/_kmcp # configure if never did echo 'fpath=( ~/.zfunc \u0026quot;${fpath[@]}\u0026quot; )' \u0026gt;\u0026gt; ~/.zshrc echo \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc fish:\nlexicmap autocompletion --shell fish --file ~/.config/fish/completions/lexicmap.fish ","description":"LexicMap can be installed via conda, executable binary files, or compiling from the source.\nBesides, it supports shell completion, which could help accelerate typing.\nConda Install conda, then run\nconda install -c bioconda lexicmap Binary files Linux Download the binary file.\nOS Arch File, 中国镜像 Linux 64-bit lexicmap_linux_amd64.tar.gz, 中国镜像 Linux arm64 lexicmap_linux_arm64.tar.gz, 中国镜像 Decompress it\ntar -zxvf lexicmap_linux_amd64.tar.gz If you have the root privilege, simply copy it to /usr/local/bin:\nsudo cp lexicmap /usr/local/bin/ Or copy to anywhere in the environment variable PATH:"},{"id":6,"href":"/LexicMap/usage/search/","title":"search","parent":"Usage","content":"$ lexicmap search -h Search sequences against an index Attention: 1. Input should be (gzipped) FASTA or FASTQ records from files or stdin. Alignment result relationship: Query ├── Subject genome ├── Subject sequence ├── High-Scoring segment Pairs (HSP) ├── HSP segment Output format: Tab-delimited format with 18 columns. (The positions are 1-based). 1. query, Query sequence ID. 2. qlen, Query sequence length. 3. qstart, Start of alignment in query sequence. 4. qend, End of alignment in query sequence. 5. hits, The number of Subject genomes. 6. sgenome, Subject genome ID. 7. seqid, Subject sequence ID. 8. qcovGnm, Query coverage (percentage) per genome: $(aligned bases in the genome)/$qlen. 9. hsp, Nth HSP in the genome. 10. qcovHSP Query coverage (percentage) per HSP: $(aligned bases in a HSP)/$qlen. 11. alen, Aligned length in the current HSP, a HSP might have \u0026gt;=1 HSP segments. 12. alenSeg, Aligned length in the current HSP segment. 13. pident, Percentage of identical matches in the current HSP segment. 14. slen, Subject sequence length. 15. sstart, Start of HSP segment in subject sequence. 16. send, End of HSP segment in subject sequence. 17. sstr, Subject strand. 18. seeds, Number of seeds in the current HSP. Usage: lexicmap search [flags] -d \u0026lt;index path\u0026gt; [query.fasta.gz ...] [-o query.tsv.gz] Flags: --align-band int ► Band size in backtracking the score matrix (default 100) --align-ext-len int ► Extend length of upstream and downstream of seed regions, for extracting query and target sequences for alignment (default 2000) --align-max-gap int ► Maximum gap in a HSP segment (default 50) --align-max-mismatch int ► Maximum mismatch in a HSP segment (default 50) -l, --align-min-match-len int ► Minimum aligned length in a HSP segment (default 50) -i, --align-min-match-pident float ► Minimum base identity (percentage) in a HSP segment. (default 70) -h, --help help for search -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -w, --load-whole-seeds ► Load the whole seed data into memory for faster search. --max-open-files int ► Maximum opened files. (default 512) -Q, --min-qcov-per-genome float ► Minimum query coverage (percentage) per genome. (default 50) -q, --min-qcov-per-hsp float ► Minimum query coverage (percentage) per HSP. -o, --out-file string ► Out file, supports a \u0026#34;.gz\u0026#34; suffix (\u0026#34;-\u0026#34; for stdout). (default \u0026#34;-\u0026#34;) --seed-max-dist int ► Max distance between seeds in seed chaining. (default 10000) --seed-max-gap int ► Max gap in seed chaining. (default 2000) -m, --seed-max-mismatch int ► Minimum mismatch between non-prefix regions of shared substrings. (default -1) -p, --seed-min-prefix int ► Minimum length of shared substrings (anchors). (default 15) -P, --seed-min-single-prefix int ► Minimum length of shared substrings (anchors) if there\u0026#39;s only one pair. (default 20) -n, --top-n-genomes int ► Keep top N genome matches for a query (0 for all). (default 1000) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples See Searching ","description":"$ lexicmap search -h Search sequences against an index Attention: 1. Input should be (gzipped) FASTA or FASTQ records from files or stdin. Alignment result relationship: Query ├── Subject genome ├── Subject sequence ├── High-Scoring segment Pairs (HSP) ├── HSP segment Output format: Tab-delimited format with 18 columns. (The positions are 1-based). 1. query, Query sequence ID. 2. qlen, Query sequence length. 3. qstart, Start of alignment in query sequence. 4."},{"id":7,"href":"/LexicMap/usage/utils/subseq/","title":"subseq","parent":"utils","content":" Usage $ lexicmap utils subseq -h Exextract subsequence via reference name, sequence ID, position and strand Attention: 1. The option -s/--seq-id is optional. 1) If given, the positions are these in the original sequence. 2) If not given, the positions are these in the concatenated sequence. Usage: lexicmap utils subseq [flags] Flags: -h, --help help for subseq -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -w, --line-width int ► Line width of sequence (0 for no wrap). (default 60) -o, --out-file string ► Out file, supports and recommends a \u0026#34;.gz\u0026#34; suffix (\u0026#34;-\u0026#34; for stdout). (default \u0026#34;-\u0026#34;) -n, --ref-name string ► Reference name. -r, --region string ► Region of the subsequence (1-based). -R, --revcom ► Extract subsequence on the negative strand. -s, --seq-id string ► Sequence ID. If the value is empty, the positions in the region are treated as that in the concatenated sequence. Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples Extracting subsequence with genome ID, sequence ID, position range and strand information.\n$ lexicmap utils subseq -d demo.lmi/ -n GCF_003697165.2 -s NZ_CP033092.2 -r 4591684:4593225 -R \u0026gt;NZ_CP033092.2:4591684-4593225 AAATTGAAGAGTTTGATCATGGCTCAGATTGAACGCTGGCGGCAGGCCTAACACATGCAA GTCGAACGGTAACAGGAAGCAGCTTGCTGCTTTGCTGACGAGTGGCGGACGGGTGAGTAA TGTCTGGGAAACTGCCTGATGGAGGGGGATAACTACTGGAAACGGTAGCTAATACCGCAT AACGTCGCAAGACCAAAGAGGGGGACCTTAGGGCCTCTTGCCATCGGATGTGCCCAGATG GGATTAGCTAGTAGGTGGGGTAACGGCTCACCTAGGCGACGATCCCTAGCTGGTCTGAGA GGATGACCAGCCACACTGGAACTGAGACACGGTCCAGACTCCTACGGGAGGCAGCAGTGG GGAATATTGCACAATGGGCGCAAGCCTGATGCAGCCATGCCGCGTGTATGAAGAAGGCCT TCGGGTTGTAAAGTACTTTCAGCGGGGAGGAAGGGAGTAAAGTTAATACCTTTGCTCATT GACGTTACCCGCAGAAGAAGCACCGGCTAACTCCGTGCCAGCAGCCGCGGTAATACGGAG GGTGCAAGCGTTAATCGGAATTACTGGGCGTAAAGCGCACGCAGGCGGTTTGTTAAGTCA GATGTGAAATCCCCGGGCTCAACCTGGGAACTGCATCTGATACTGGCAAGCTTGAGTCTC GTAGAGGGGGGTAGAATTCCAGGTGTAGCGGTGAAATGCGTAGAGATCTGGAGGAATACC GGTGGCGAAGGCGGCCCCCTGGACGAAGACTGACGCTCAGGTGCGAAAGCGTGGGGAGCA AACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGTCGACTTGGAGGTTGTGCC CTTGAGGCGTGGCTTCCGGAGCTAACGCGTTAAGTCGACCGCCTGGGGAGTACGGCCGCA AGGTTAAAACTCAAATGAATTGACGGGGGCCCGCACAAGCGGTGGAGCATGTGGTTTAAT TCGATGCAACGCGAAGAACCTTACCTGGTCTTGACATCCACGGAAGTTTTCAGAGATGAG AATGTGCCTTCGGGAACCGTGAGACAGGTGCTGCATGGCTGTCGTCAGCTCGTGTTGTGA AATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTATCCTTTGTTGCCAGCGGTCCGGC CGGGAACTCAAAGGAGACTGCCAGTGATAAACTGGAGGAAGGTGGGGATGACGTCAAGTC ATCATGGCCCTTACGACCAGGGCTACACACGTGCTACAATGGCGCATACAAAGAGAAGCG ACCTCGCGAGAGCAAGCGGACCTCATAAAGTGCGTCGTAGTCCGGATTGGAGTCTGCAAC TCGACTCCATGAAGTCGGAATCGCTAGTAATCGTGGATCAGAATGCCACGGTGAATACGT TCCCGGGCCTTGTACACACCGCCCGTCACACCATGGGAGTGGGTTGCAAAAGAAGTAGGT AGCTTAACCTTCGGGAGGGCGCTTACCACTTTGTGATTCATGACTGGGGTGAAGTCGTAA CAAGGTAACCGTAGGGGAACCTGCGGTTGGATCACCTCCTTA If the sequence ID (-s/--seq-id) is not given, the positions are these in the concatenated sequence.\nChecking sequence lengths of a genome with seqkit.\n$ seqkit fx2tab -nil refs/GCF_003697165.2.fa.gz NZ_CP033092.2 4903501 NZ_CP033091.2 131333 Extracting the 1000-bp interval sequence inserted by lexicmap index.\n$ lexicmap utils subseq -d demo.lmi/ -n GCF_003697165.2 -r 4903502:4904501 \u0026gt;GCF_003697165.2:4903502-4904501 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ","description":"Usage $ lexicmap utils subseq -h Exextract subsequence via reference name, sequence ID, position and strand Attention: 1. The option -s/--seq-id is optional. 1) If given, the positions are these in the original sequence. 2) If not given, the positions are these in the concatenated sequence. Usage: lexicmap utils subseq [flags] Flags: -h, --help help for subseq -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -w, --line-width int ► Line width of sequence (0 for no wrap)."},{"id":8,"href":"/LexicMap/releases/","title":"Releases","parent":"","content":" Latest version v0.3.0 v0.3.0 - 2024-04-xx lexicmap index: Generate masks from the top N biggest genomes instead of randomly generation. Use longer (1000bp N\u0026rsquo;s, previous: k-1) intervals between contigs. Fix a concurrency bug between genome data writing and k-mer-value data collecting. Change the format of k-mer-value index file, and fix the computation of index partitions. lexicmap search: Better support of long queries. Add a new flag -w/--load-whole-seeds for loading the whole seed data into memory for faster search. Parallelize alignment in each query, so it\u0026rsquo;s faster for a single query. Change output format. Add output of query start and end positions. Fix a seed-chaining bug. Fix a target sequence extracting bug. Keep indexes of genome data in memory. lexicmap utils kmers: Fix a little bug, wrong number of k-mers for the second k-mer in each k-mer pair. New commands: lexicmap utils gen-masks for generating masks from the top N largest genomes. lexicmap utils seed-pos for extracting seed positions via reference names. lexicmap utils reindex-seeds for recreating indexes of k-mer-value (seeds) data. Please run lexicmap version to check update !!! Please run lexicmap autocompletion to update shell autocompletion script !!! Previous versions v0.2.0 v0.2.0 - 2024-02-02 Software architecture and index formats are redesigned to reduce searching memory occupation. Indexing: genomes are processed in batches to reduce RAM usage, then indexes of all batches are merged. Searching: seeds matching is performed on disk yet it\u0026rsquo;s ultra-fast. v0.1.0 v0.1.0 - 2024-01-15 The first release. Seed indexing and querying are performed in RAM. GTDB r214 with 10k masks: index size 75GB, RAM: 130GB. ","description":"Latest version v0.3.0 v0.3.0 - 2024-04-xx lexicmap index: Generate masks from the top N biggest genomes instead of randomly generation. Use longer (1000bp N\u0026rsquo;s, previous: k-1) intervals between contigs. Fix a concurrency bug between genome data writing and k-mer-value data collecting. Change the format of k-mer-value index file, and fix the computation of index partitions. lexicmap search: Better support of long queries. Add a new flag -w/--load-whole-seeds for loading the whole seed data into memory for faster search."},{"id":9,"href":"/LexicMap/usage/utils/seed-pos/","title":"seed-pos","parent":"utils","content":" Usage $ lexicmap utils seed-pos -h Extract seed positions via reference names Attentions: 0. This command requires the index to be created with the flag --save-seed-pos in lexicmap index. 1. Seed/K-mer positions (column pos) are 1-based. For reference genomes with multiple sequences, the sequences were concatenated to a single sequence with intervals of N\u0026#39;s. The positions can be used to extract subsequence with \u0026#39;lexicmap utils subseq\u0026#39;. 2. A distance between seeds (column distance) with a value of \u0026#34;-1\u0026#34; means it\u0026#39;s the first seed in that sequence, and the distance can\u0026#39;t be computed currently. Usage: lexicmap utils seed-pos [flags] Flags: -a, --all-refs ► Output for all reference genomes. This would take a long time for an index with a lot of genomes. -b, --bins int ► Number of bins in histograms. (default 100) --color-index int ► Color index (1-7). (default 1) --force ► Overwrite existing output directory. --height float ► Histogram height (unit: inch). (default 4) -h, --help help for seed-pos -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -o, --out-file string ► Out file, supports and recommends a \u0026#34;.gz\u0026#34; suffix (\u0026#34;-\u0026#34; for stdout). (default \u0026#34;-\u0026#34;) -O, --plot-dir string ► Output directory for histograms of seed distances. --plot-ext string ► Histogram plot file extention. (default \u0026#34;.png\u0026#34;) -t, --plot-title ► Plot genome ID as the title. -n, --ref-name strings ► Reference name(s). --width float ► Histogram width (unit: inch). (default 6) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples Adding the flag --save-seed-pos in index building.\n$ lexicmap index -I refs/ -O demo.lmi --save-seed-pos --force Listing seed position of one genome.\n$ lexicmap utils seed-pos -d demo.lmi/ -n GCF_000017205.1 -o seed_distance.tsv $ head -n 10 seed_distance.tsv | csvtk pretty -t ref pos strand distance --------------- --- ------ -------- GCF_000017205.1 2 + 1 GCF_000017205.1 41 + 39 GCF_000017205.1 45 + 4 GCF_000017205.1 74 + 29 GCF_000017205.1 85 + 11 GCF_000017205.1 119 + 34 GCF_000017205.1 130 + 11 GCF_000017205.1 185 + 55 GCF_000017205.1 269 + 84 Check the biggest seed distances.\n$ csvtk freq -t -f distance seed_distance.tsv \\ | csvtk sort -t -k distance:nr \\ | head -n 20 \\ | csvtk pretty -t distance frequency -------- --------- 1234 1 899 2 898 4 897 1 896 5 895 4 894 3 893 3 892 4 891 2 890 2 889 2 888 3 887 4 886 7 885 2 884 5 883 2 881 6 Plot the histogram of distances between seeds.\n$ lexicmap utils seed-pos -d demo.lmi/ -n GCF_000017205.1 -o seed_distance.tsv --plot-dir seed_distance In the plot below, there\u0026rsquo;s a peak at 200 bp, because LexicMap fills sketching deserts with extra k-mers (seeds) of which their distance is 200 bp by default.\nListing seed position of all genomes.\n$ lexicmap utils seed-pos -d demo.lmi/ --all-refs -o seed-pos.tsv.gz Show the number of seed positions in each genome. Frequencies larger than 40000 (the number of masks) means some k-mers can be foud in more than one positions in a genome.\n$ csvtk freq -t -f ref -nr seed-pos.tsv.gz | csvtk pretty -t ref frequency --------------- --------- GCF_000017205.1 45708 GCF_002950215.1 43617 GCF_002949675.1 43411 GCF_001457655.1 42112 GCF_006742205.1 42103 GCF_900638025.1 42008 GCF_001027105.1 41856 GCF_000742135.1 41414 GCF_000392875.1 41392 GCF_003697165.2 41189 GCF_009759685.1 41137 GCF_000006945.2 41108 GCF_000148585.2 41075 GCF_001096185.1 40239 GCF_001544255.1 40159 Plot the histograms of distances between seeds for all genomes.\n$ lexicmap utils seed-pos -d demo.lmi/ --all-refs -o seed-pos.tsv.gz --plot-dir seed_distance processed files: 15 / 15 [======================================] ETA: 0s. done 11:48:31.346 [INFO] seed positions of 15 genomes(s) saved to seed-pos.tsv.gz 11:48:31.346 [INFO] histograms of 15 genomes(s) saved to seed_distance $ ls seed_distance/ GCF_000006945.2.png GCF_000392875.1.png GCF_001096185.1.png GCF_002949675.1.png GCF_006742205.1.png GCF_000017205.1.png GCF_000742135.1.png GCF_001457655.1.png GCF_002950215.1.png GCF_009759685.1.png GCF_000148585.2.png GCF_001027105.1.png GCF_001544255.1.png GCF_003697165.2.png GCF_900638025.1.png The output (TSV format) is formatted with csvtk pretty.\n","description":"Usage $ lexicmap utils seed-pos -h Extract seed positions via reference names Attentions: 0. This command requires the index to be created with the flag --save-seed-pos in lexicmap index. 1. Seed/K-mer positions (column pos) are 1-based. For reference genomes with multiple sequences, the sequences were concatenated to a single sequence with intervals of N\u0026#39;s. The positions can be used to extract subsequence with \u0026#39;lexicmap utils subseq\u0026#39;. 2. A distance between seeds (column distance) with a value of \u0026#34;-1\u0026#34; means it\u0026#39;s the first seed in that sequence, and the distance can\u0026#39;t be computed currently."},{"id":10,"href":"/LexicMap/tutorials/","title":"Tutorials","parent":"","content":"","description":""},{"id":11,"href":"/LexicMap/usage/utils/","title":"utils","parent":"Usage","content":"$ lexicmap utils Some utilities Usage: lexicmap utils [command] Available Commands: kmers View k-mers captured by the masks masks View masks of the index or generate new masks randomly reindex-seeds Recreate indexes of k-mer-value (seeds) data seed-pos Extract seed positions via reference names subseq Extract subsequence via reference name, sequence ID, position and strand Flags: -h, --help help for utils Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) The output (TSV format) is formatted with csvtk pretty.\n","description":"$ lexicmap utils Some utilities Usage: lexicmap utils [command] Available Commands: kmers View k-mers captured by the masks masks View masks of the index or generate new masks randomly reindex-seeds Recreate indexes of k-mer-value (seeds) data seed-pos Extract seed positions via reference names subseq Extract subsequence via reference name, sequence ID, position and strand Flags: -h, --help help for utils Global Flags: -X, --infile-list string ► File of input file list (one file per line)."},{"id":12,"href":"/LexicMap/usage/utils/reindex-seeds/","title":"reindex-seeds","parent":"utils","content":" Usage $ lexicmap utils reindex-seeds -h Recreate indexes of k-mer-value (seeds) data Usage: lexicmap utils reindex-seeds [flags] Flags: -h, --help help for reindex-seeds -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. --partitions int ► Number of partitions for re-indexing seeds (k-mer-value data) files. (default 512) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples $ lexicmap utils reindex-seeds -d demo.lmi/ --partitions 1024 10:20:29.150 [INFO] recreating seed indexes with 1024 partitions for: demo.lmi/ processed files: 16 / 16 [======================================] ETA: 0s. done 10:20:29.166 [INFO] update index information file: demo.lmi/info.toml 10:20:29.166 [INFO] finished updating the index information file: demo.lmi/info.toml 10:20:29.166 [INFO] 10:20:29.166 [INFO] elapsed time: 15.981266ms 10:20:29.166 [INFO] ","description":"Usage $ lexicmap utils reindex-seeds -h Recreate indexes of k-mer-value (seeds) data Usage: lexicmap utils reindex-seeds [flags] Flags: -h, --help help for reindex-seeds -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. --partitions int ► Number of partitions for re-indexing seeds (k-mer-value data) files. (default 512) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments."},{"id":13,"href":"/LexicMap/usage/","title":"Usage","parent":"","content":"","description":""},{"id":14,"href":"/LexicMap/faqs/","title":"FAQs","parent":"","content":" Does LexicMap support fungi genomes? Yes. LexicMap mainly supports small genomes including prokaryotic, viral, and plasmid genomes. Fungi can be supported with more masks.\nDoes LexicMap support short reads? No. LexicMap only supports long (\u0026gt;=500 bp, \u0026gt;=1kb is prefered) reads or gene/genome/virus/plasmid/phage sequences. However, some short queries can also be aligned.\nHow\u0026rsquo;s the hardware requirement? For index building. See details hardware requirement.\nMore CPUs would accelerate indexing. The memory occupation is linear with The size of the genome batch. The number of LexicHash masks. For seaching. See details hardware requirement.\nMore CPUs would accelerate searching. The memory occupation mainly depends on the length of queries, the number of hits, and band size in backtracking. Why is LexicMap slow for batch searching? LexicMap is mainly designed for sequence alignment with a small number of queries against a database with a huge number of genomes.\nlexicmap search has a flag -w/--load-whole-seeds to load the whole seed data into memory for faster search.\nFor example, for ~85,000 GTDB representative genomes, searching on an index built with 20,000 masks, the memory would be ~100 GB with default parameters. Click to read more detail of the usage. ","description":"Does LexicMap support fungi genomes? Yes. LexicMap mainly supports small genomes including prokaryotic, viral, and plasmid genomes. Fungi can be supported with more masks.\nDoes LexicMap support short reads? No. LexicMap only supports long (\u0026gt;=500 bp, \u0026gt;=1kb is prefered) reads or gene/genome/virus/plasmid/phage sequences. However, some short queries can also be aligned.\nHow\u0026rsquo;s the hardware requirement? For index building. See details hardware requirement.\nMore CPUs would accelerate indexing. The memory occupation is linear with The size of the genome batch."},{"id":15,"href":"/LexicMap/notes/","title":"Notes","parent":"","content":"","description":""},{"id":16,"href":"/LexicMap/","title":"","parent":"","content":" LexicMap LexicMap is a sequence alignment tool aiming to efficiently query gene/plasmid/virus/long-read sequences against up to millions of prokaryotic genomes.\nQuick start Feature overview Easy to install Both x86 and ARM CPUs are supported. Just install it by\nconda install -c bioconda lexicmap Or download the binary files for popular patforms.\nInstallation Releases Easy to use # indexing lexicmap index -I genomes/ -O db.lmi # searching lexicmap search -d db.lmi q.fasta -o r.tsv Introduction Tutorials Usages FAQs Notes Efficient search Querying a 51.5-kb plasmid in all 2,340,672 Genbank+Refseq prokaryotic genomes takes only 5 minutes and 2 seconds with 13.7 GB RAM and 48 CPUs, with 17,822 genome hits returned.\nPerformance ","description":"LexicMap LexicMap is a sequence alignment tool aiming to efficiently query gene/plasmid/virus/long-read sequences against up to millions of prokaryotic genomes.\nQuick start Feature overview Easy to install Both x86 and ARM CPUs are supported. Just install it by\nconda install -c bioconda lexicmap Or download the binary files for popular patforms.\nInstallation Releases Easy to use # indexing lexicmap index -I genomes/ -O db.lmi # searching lexicmap search -d db."},{"id":17,"href":"/LexicMap/tutorials/index/","title":"Building an index","parent":"Tutorials","content":" Table of contents Table of contents TL;DR Input Hardware requirements Algorithm Parameters Steps Output File structure Index size TL;DR Prepare input files: Sequences of each reference genome should be saved in separate FASTA/Q files, with identifiers in the file names. Run: From a directory with multiple genome files:\nlexicmap index -I genomes/ -O db.lmi From a file list with one file per line:\nlexicmap index -X files.txt -O db.lmi Input Genome size\nLexicMap is only suitable for small genomes like Archaea, Bacteria, Viruses and plasmids. Sequences of each reference genome should be saved in separate FASTA/Q files, with identifiers in the file names.\nFile type: FASTA/Q files, in plain text or gzip-compressed format. File name: \u0026ldquo;Genome ID\u0026rdquo; + \u0026ldquo;File extention\u0026rdquo;. E.g., GCF_000006945.2.fa.gz. Genome ID: they should be distinct for accurate result interpretation, which will be shown in the search result. File extention: a regular expression set by the flag -N/--ref-name-regexp is used to extract genome IDs from the file name. The default value supports common sequence file extentions, including .fa, .fasta, .fna, .fa.gz, .fasta.gz, and .fna.gz. Sequences: Only DNA or RNA sequences are supported. Sequence IDs should be distinct for accurate result interpretation, which will be shown in the search result. One or more sequences are allowed. Unwanted sequences can be filtered out by regular expressions from the flag -B/--seq-name-filter. Genome size limit. Some none-isolate assemblies might have extremely large genomes, e.g., GCA_000765055.1 has \u0026gt;150 Mb. The flag -g/--max-genome (default 15 Mb) is used to skip these input files, and the file list would be written to a file via the flag -G/--big-genomes. At most 17,179,869,184 genomes are supported. For more genomes, just build multiple indexes. Input files can be given via one of the following ways:\nPositional arguments. For a few input files. A file list via the flag -X/--infile-list with one file per line. It can be STDIN (-), e.g., you can filter a file list and pass it to lexicmap index. A directory containing input files via the flag -I/--in-dir. Multiple-level directories are supported. Directory and file symlinks are followed. Hardware requirements LexicMap is designed to provide fast and low-memory sequence alignment against millions of prokaryotic genomes.\nCPU: No specific requirements on CPU type and instruction sets. Both x86 and ARM chips are supported. More is better as LexicMap is a CPU-intensive software. It uses all CPUs by default (-j/--threads). RAM More RAM (\u0026gt; 50 GB) is preferred. The memory usage in index building is mainly related to: The number of masks (-m, --masks, default 40,000). The number of genome. The divergence between genome sequences. The genome batch size (-b/--batch-size, default 10,000). If the RAM is not sufficient (\u0026lt; 50 GB). Please: Use a smaller genome batch size. It decreases indexing memory occupation and has little effect on searching performance. Use a smaller number of masks, e.g., 20,000 performs well for small genomes (\u0026lt;=5 Mb). And if the queries are long (\u0026gt;= 2kb), there\u0026rsquo;s little affection for the alignment results. Disk More (\u0026gt;2 TB) is better. The index size is related to the input genomes and the number of masks. See some examples. SSD disks are preferred, while HDD disks are also fast enough. Algorithm Generating m LexicHash masks.\nGenerate m prefixes. Generating all permutations of p-bp prefixes that can cover all possible k-mers, p is the biggest value for 4p \u0026lt;= m (desired number of masks), e.g., p=7 for 40,000 masks. Removing low-complexity prefixes. E.g., 16176 out of 16384 (4^7) prefixes are left. Duplicating these prefixes to m prefixes. For each prefixes, Randomly generating left k-p bases. If the P-prefix (-p/--seed-min-prefix) is of low-complexity, re-generating. P is the minimum length of substring matches, default 15. If the mask is duplicated, re-generating. Building an index for each genome batch (-b/--batch-size, default 10000, max 131072).\nFor each genome file in a genome batch. Optionally discarding sequences via regular expression (-B/--seq-name-filter). Skipping genomes bigger than the value of -g/--max-genome. Concatenating all sequences, with intervals of 1000-bp N\u0026rsquo;s (). Capuring the most similar k-mer for each mask and recording the k-mer and its location(s) and strand information. Filling sketching deserts (genome regions longer than --seed-max-desert without any captured k-mers/seeds). In a sketching desert, not a single k-mer is captured because there\u0026rsquo;s another k-mer in another place which shares a longer prefix with the mask. As a result, for a query similar to seqs in this region, all captured k-mers can’t match the correct seeds. For a desert region (start, end), counting frequencies of P-mers in the extended region (start-1000, end+1000), P=15 by default. Starting from start, every around --seed-in-desert-dist bp, finding a k-mer of which the P-prefix is unique with a frequency of 1 (from the previous step). This guarantees the k-mer will be captured by a mask in query sequences similar to the region. Adding the new k-mer to the mask which has the biggest chance to capture it. So in the search step, the new k-mer will be captured by this mask, and it will match the correst seed (its self) in the seed data of the mask. Find candidate masks via a lookup table (mapping mask prefix to mask). Choose the mask of which the captured k-mer share the longest prefix as the new k-mer, by compring LexicHash values (new k-mer XOR captured k-mer). Saving the concatenated genome sequence (bit-packed, 2 bits for one base) and genome information (genome ID, size, and lengths of all sequences) into the genome data file, and creating an index file for the genome data file for fast random subsequence extraction. Compressing k-mers and the corresponding data (k-mer-data, or seeds data, including genome batch, genome number, location, and strand) into chunks of files, and creating an index file for each k-mer-data file for fast seeding. Writing summary information into info.toml file. Merging indexes of multiple batches.\nFor each k-mer-data chunk file (belonging to a list of masks), serially reading data of each mask from all batches, merging them and writting to a new file. For genome data files, just moving them. Concatenating genomes.map.bin, which maps each genome ID to its batch ID and index in the batch. Update index summary file. Parameters Flags in bold text are important and frequently used.\nGenome batches Flag Value Function Comment -b/--batch-size Max: 131072, default: 10000 Maximum number of genomes in each batch If the number of input files exceeds this number, input files are split into multiple batches and indexes are built for all batches. In the end, seed files are merged, while genome data files are kept unchanged and collected. ► Bigger values increase indexing memory occupation LexicHash mask generation Flag Value Function Comment -M/--mask-file A file File with custom masks File with custom masks, which could be exported from an existing index or newly generated by \u0026ldquo;lexicmap utils masks\u0026rdquo;. This flag oversides -k/\u0026ndash;kmer, -m/\u0026ndash;masks, -s/\u0026ndash;rand-seed, et al. -k/--kmer Max: 32, default: 31 K-mer size ► Bigger values improve the search specificity and do not increase the index size. -m/--masks Default: 40000 Number of masks ► Bigger values improve the search sensitivity, increase the index size, and slow down the search speed. -p/--seed-min-prefix Max: 32, Default: 15 Minimum length of shared substrings (anchors) in searching This value is used to remove masks with a prefix of low-complexity and choose k-mers to fill sketching deserts. Seeds (k-mer-value) data Flag Value Function Comment -c/--chunks Maximum: 128, default: #CPUs Number of seed file chunks Bigger values accelerate the search speed at the cost of a high disk reading load. The maximum number should not exceed the maximum number of open files set by the operating systems. -p/--partitions Default: 512 Number of partitions for indexing each seed file Bigger values bring a little higher memory occupation. 512 is a good value with high searching speed, larger or smaller values would decrease the speed in lexicmap search. ► After indexing, lexicmap utils reindex-seeds can be used to reindex the seeds data with another value of this flag. --max-open-files Default: 512 Maximum number of open files It\u0026rsquo;s only used in merging indexes of multiple genome batches. Also see the usage of lexicmap index.\nSteps We use a small dataset for demonstration.\nPreparing the test genomes (15 bacterial genomes) in the refs directory.\nNote that the genome files contain the assembly accessions (ID) in the file names.\ngit clone https://github.com/shenwei356/LexicMap cd LexicMap/demo/ ls refs/ GCF_000006945.2.fa.gz GCF_000392875.1.fa.gz GCF_001096185.1.fa.gz GCF_002949675.1.fa.gz GCF_006742205.1.fa.gz GCF_000017205.1.fa.gz GCF_000742135.1.fa.gz GCF_001457655.1.fa.gz GCF_002950215.1.fa.gz GCF_009759685.1.fa.gz GCF_000148585.2.fa.gz GCF_001027105.1.fa.gz GCF_001544255.1.fa.gz GCF_003697165.2.fa.gz GCF_900638025.1.fa.gz Building an index with genomes from a directory.\nlexicmap index -I refs/ -O demo.lmi It would take about 2 seconds and 2 GB RAM in a 16-CPU PC.\nOptionally, we can also use a file list as the input.\n$ head -n 3 files.txt refs/GCF_000006945.2.fa.gz refs/GCF_000017205.1.fa.gz refs/GCF_000148585.2.fa.gz lexicmap index -X files.txt -O demo.lmi Click to show the log of a demo run. ... $ lexicmap index -I refs/ -O demo.lmi --batch-size 5 20:24:16.138 [INFO] LexicMap v0.3.0 20:24:16.138 [INFO] https://github.com/shenwei356/LexicMap 20:24:16.138 [INFO] 20:24:16.138 [INFO] checking input files ... 20:24:16.138 [INFO] 15 input file(s) given 20:24:16.138 [INFO] 20:24:16.138 [INFO] --------------------- [ main parameters ] --------------------- 20:24:16.138 [INFO] 20:24:16.138 [INFO] input and output: 20:24:16.138 [INFO] input directory: refs/ 20:24:16.138 [INFO] regular expression of input files: (?i)\\.(f[aq](st[aq])?|fna)(.gz)?$ 20:24:16.138 [INFO] *regular expression for extracting reference name from file name: (?i)(.+)\\.(f[aq](st[aq])?|fna)(.gz)?$ 20:24:16.138 [INFO] *regular expressions for filtering out sequences: [] 20:24:16.138 [INFO] max genome size: 15000000 20:24:16.138 [INFO] output directory: demo.lmi 20:24:16.138 [INFO] 20:24:16.138 [INFO] k-mer size: 31 20:24:16.138 [INFO] number of masks: 40000 20:24:16.138 [INFO] rand seed: 1 20:24:16.138 [INFO] maximum sketching desert length: 900 20:24:16.138 [INFO] prefix for checking low-complexity and choosing k-mers to fill sketching deserts: 15 20:24:16.138 [INFO] distance of k-mers to fill deserts: 200 20:24:16.139 [INFO] 20:24:16.139 [INFO] 20:24:16.139 [INFO] seeds data chunks: 16 20:24:16.139 [INFO] seeds data indexing partitions: 512 20:24:16.139 [INFO] genome batch size: 5 20:24:16.139 [INFO] 20:24:16.139 [INFO] 20:24:16.139 [INFO] --------------------- [ generating masks ] --------------------- 20:24:16.448 [INFO] 20:24:16.449 [INFO] --------------------- [ building index ] --------------------- 20:24:16.588 [INFO] 20:24:16.588 [INFO] ------------------------[ batch 0 ]------------------------ 20:24:16.588 [INFO] building index for batch 0 with 5 files... processed files: 5 / 5 [======================================] ETA: 0s. done 20:24:17.137 [INFO] writing seeds... 20:24:17.276 [INFO] finished writing seeds in 139.057887ms 20:24:17.276 [INFO] finished building index for batch 0 in: 688.321313ms 20:24:17.276 [INFO] 20:24:17.276 [INFO] ------------------------[ batch 1 ]------------------------ 20:24:17.276 [INFO] building index for batch 1 with 5 files... processed files: 5 / 5 [======================================] ETA: 0s. done 20:24:18.533 [INFO] writing seeds... 20:24:18.711 [INFO] finished writing seeds in 178.082436ms 20:24:18.711 [INFO] finished building index for batch 1 in: 1.435404512s 20:24:18.711 [INFO] 20:24:18.711 [INFO] ------------------------[ batch 2 ]------------------------ 20:24:18.711 [INFO] building index for batch 2 with 5 files... processed files: 5 / 5 [======================================] ETA: 0s. done 20:24:19.428 [INFO] writing seeds... 20:24:19.608 [INFO] finished writing seeds in 179.258899ms 20:24:19.608 [INFO] finished building index for batch 2 in: 896.434874ms 20:24:19.608 [INFO] 20:24:19.608 [INFO] merging 3 indexes... 20:24:19.608 [INFO] [round 1] 20:24:19.608 [INFO] batch 1/1, merging 3 indexes to demo.lmi.tmp/r1_b1 20:24:20.173 [INFO] [round 1] finished in 565.004912ms 20:24:20.173 [INFO] rename demo.lmi.tmp/r1_b1 to demo.lmi 20:24:20.178 [INFO] 20:24:20.178 [INFO] finished building LexicMap index from 15 files with 40000 masks in 4.039522685s 20:24:20.178 [INFO] LexicMap index saved: demo.lmi 20:24:20.178 [INFO] 20:24:20.178 [INFO] elapsed time: 4.039558932s 20:24:20.178 [INFO] Output The LexicMap index is a directory with multiple files.\nFile structure $ tree demo.lmi/ demo.lmi/ # the index directory ├── genomes # directory of genome data │ └── batch_0000 # genome data of a batch │ ├── genomes.bin # genome data file, containing genome ID, size, sequence lengths, bit-packed sequences │ └── genomes.bin.idx # index of genome data file, for fast subsequence extraction ├── seeds # seed data: pairs of k-mer and its location information (genome batch, genome number, location, strand) │ ├── chunk_000.bin # seed data file │ ├── chunk_000.bin.idx # index of seed data file, for fast seed searching and data extraction ... ... ... │ ├── chunk_015.bin # the number of chunks is set by flag `-c/--chunks`, default: #cpus │ └── chunk_015.bin.idx ├── genomes.map.bin # mapping genome ID to batch number of genome number in the batch ├── info.toml # summary of the index ├── masks.bin # mask data Index size Demo data # 15 genomes $ dirsize demo.lmi/ demo.lmi/: 26.90 MB 13.67 MB seeds 12.93 MB genomes 312.53 KB masks.bin 375.00 B genomes.map.bin 261.00 B info.toml GTDB repr # 85,205 genomes gtdb_repr.lmi: 110.37 GB 66.78 GB genomes 43.59 GB seeds 2.03 MB genomes.map.bin 312.53 KB masks.bin 266.00 B info.toml GTDB complete # 402,538 genomes gtdb_complete.lmi: 506.57 GB 362.99 GB genomes 143.57 GB seeds 9.60 MB genomes.map.bin 312.53 KB masks.bin 269.00 B info.toml Genbank\u0026#43;RefSeq # 2,340,672 genomes genbank_refseq.lmi: 2.90 TB 2.17 TB genomes 754.04 GB seeds 55.81 MB genomes.map.bin 312.53 KB masks.bin 271.00 B info.toml AllTheBacteria HQ # 1,858,610 genomes 2kk-HQ.lmi: 2.32 TB 1.77 TB genomes 563.16 GB seeds 39.22 MB genomes.map.bin 312.53 KB masks.bin 271.00 B info.toml Index building parameters: -k 31 -m 40000. Genome batch size: -b 10000 for GTDB datasets, -b 50000 for others.\nWhat\u0026rsquo;s next: Searching ","description":"Table of contents Table of contents TL;DR Input Hardware requirements Algorithm Parameters Steps Output File structure Index size TL;DR Prepare input files: Sequences of each reference genome should be saved in separate FASTA/Q files, with identifiers in the file names. Run: From a directory with multiple genome files:\nlexicmap index -I genomes/ -O db.lmi From a file list with one file per line:\nlexicmap index -X files.txt -O db.lmi Input Genome size"},{"id":18,"href":"/LexicMap/usage/lexicmap/","title":"lexicmap","parent":"Usage","content":"$ lexicmap -h LexicMap: efficient sequence alignment against millions of prokaryotic genomes Version: v0.3.0 Documents: https://bioinf.shenwei.me/LexicMap Source code: https://github.com/shenwei356/LexicMap Usage: lexicmap [command] Available Commands: autocompletion Generate shell autocompletion scripts index Generate an index from FASTA/Q sequences search Search sequences against an index utils Some utilities version Print version information and check for update Flags: -h, --help help for lexicmap -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Use \u0026#34;lexicmap [command] --help\u0026#34; for more information about a command. ","description":"$ lexicmap -h LexicMap: efficient sequence alignment against millions of prokaryotic genomes Version: v0.3.0 Documents: https://bioinf.shenwei.me/LexicMap Source code: https://github.com/shenwei356/LexicMap Usage: lexicmap [command] Available Commands: autocompletion Generate shell autocompletion scripts index Generate an index from FASTA/Q sequences search Search sequences against an index utils Some utilities version Print version information and check for update Flags: -h, --help help for lexicmap -X, --infile-list string ► File of input file list (one file per line)."},{"id":19,"href":"/LexicMap/usage/utils/masks/","title":"masks","parent":"utils","content":"$ lexicmap utils masks -h View masks of the index or generate new masks randomly Usage: lexicmap utils masks [flags] { -d \u0026lt;index path\u0026gt; | [-k \u0026lt;k\u0026gt;] [-n \u0026lt;masks\u0026gt;] [-s \u0026lt;seed\u0026gt;] } [-o out.tsv.gz] Flags: -h, --help help for masks -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -k, --kmer int ► Maximum k-mer size. K needs to be \u0026lt;= 32. (default 31) -m, --masks int ► Number of masks. (default 1000) -o, --out-file string ► Out file, supports and recommends a \u0026#34;.gz\u0026#34; suffix (\u0026#34;-\u0026#34; for stdout). (default \u0026#34;-\u0026#34;) -p, --prefix int ► Length of mask k-mer prefix for checking low-complexity (0 for no checking). (default 15) -s, --seed int ► The seed for generating random masks. (default 1) Global Flags: -X, --infile-list string ► File of input file list (one file per line). If given, they are appended to files from CLI arguments. --log string ► Log file. --quiet ► Do not print any verbose information. But you can write them to a file with --log. -j, --threads int ► Number of CPU cores to use. By default, it uses all available cores. (default 16) Examples $ lexicmap utils masks --quiet -d demo.lmi/ | head -n 10 1 AAAACACATGTGGCCGTTCCGATAATGATCC 2 AAAACACGCGATCAGGTCGTCCGTCCCAGTG 3 AAAACACTATGGCCTGATTACCCCATCCCGA 4 AAAACAGGACCGTCCTAGGGTCAATGGTTCG 5 AAAACAGTCTTGTATTATGTACTTCACATTC 6 AAAACATTCTTTCAGATCCATGCACGAGCAG 7 AAAACATTGGTCCTATTGGCGTCACTCGATA 8 AAAACCAGCTCTGTAAGCACTAACAACGCTA 9 AAAACCAGTTACTACGGTTTTCCGCAATTGG 10 AAAACCATGTGCGGCCCATAACTGGTGGTAA $ lexicmap utils masks --quiet -d demo.lmi/ | tail -n 10 39991 TTTTGGTCTACAGAAAGTGCGTTATAGATTT 39992 TTTTGGTGCTCATACAGTACCGCTGTCTCCA 39993 TTTTGTAGCGCCATACCGGAGTTCACGGGTC 39994 TTTTGTATGGAATACTTTACAGTCATCAGTT 39995 TTTTGTCATACAGGAAGCACGGTCGAACGTT 39996 TTTTGTCATCAGTCGGCACTTAGGGGAACCG 39997 TTTTGTCCACCCTATTGAAGATGGAGTCCCA 39998 TTTTGTGAATAAGAGATCCTGTCGCAGGAAA 39999 TTTTGTGGACGGTAGAACCCCGTGGTCACCA 40000 TTTTGTGTAGCATAAAGGGCTGGCGACCTGT ","description":"$ lexicmap utils masks -h View masks of the index or generate new masks randomly Usage: lexicmap utils masks [flags] { -d \u0026lt;index path\u0026gt; | [-k \u0026lt;k\u0026gt;] [-n \u0026lt;masks\u0026gt;] [-s \u0026lt;seed\u0026gt;] } [-o out.tsv.gz] Flags: -h, --help help for masks -d, --index string ► Index directory created by \u0026#34;lexicmap index\u0026#34;. -k, --kmer int ► Maximum k-mer size. K needs to be \u0026lt;= 32. (default 31) -m, --masks int ► Number of masks."},{"id":20,"href":"/LexicMap/notes/motivation/","title":"Motivation","parent":"Notes","content":" BLASTN is not able to scale to millions of bacterial genomes, it\u0026rsquo;s slow and has a high memory occupation. For example, it requires \u0026gt;2000 GB for alignment a 2-kp gene sequence against all the 2.34 millions of prokaryotics genomes in Genbank and RefSeq.\nLarge-scale sequence searching tools only return which genomes a query matches (color), but they can\u0026rsquo;t return location information.\n","description":"BLASTN is not able to scale to millions of bacterial genomes, it\u0026rsquo;s slow and has a high memory occupation. For example, it requires \u0026gt;2000 GB for alignment a 2-kp gene sequence against all the 2.34 millions of prokaryotics genomes in Genbank and RefSeq.\nLarge-scale sequence searching tools only return which genomes a query matches (color), but they can\u0026rsquo;t return location information."},{"id":21,"href":"/LexicMap/tags/","title":"Tags","parent":"","content":"","description":""}]