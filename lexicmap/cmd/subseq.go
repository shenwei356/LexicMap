// Copyright Â© 2023-2024 Wei Shen <shenwei356@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/shenwei356/LexicMap/lexicmap/cmd/genome"
	"github.com/shenwei356/bio/seq"
	"github.com/shenwei356/xopen"
	"github.com/spf13/cobra"
)

var subseqCmd = &cobra.Command{
	Use:   "subseq",
	Short: "Extract subsequence via 1) reference name, sequence ID, position and strand, or 2) search result",
	Long: `Exextract subsequence via 1) reference name, sequence ID, position and strand, or 2) search result

Input:
  - Manually specify reference name, sequence ID, region, and strand.
  - Or give an output file generated by "lexicmap search".

Attention:
  1. The option -s/--seq-id is optional.
     1) If given, the positions are these in the original sequence.
     2) If not given, the positions are these in the concatenated sequence.
  2. All degenerate bases in reference genomes were converted to the lexicographic first bases.
     E.g., N was converted to A. Therefore, consecutive A's in output might be N's in the genomes.

`,
	Run: func(cmd *cobra.Command, args []string) {
		opt := getOptions(cmd)
		seq.ValidateSeq = false

		timeStart0 := time.Now()

		// ------------------------------

		dbDir := getFlagString(cmd, "index")
		if dbDir == "" {
			checkError(fmt.Errorf("flag -d/--index needed"))
		}

		outFile := getFlagString(cmd, "out-file")
		lineWidth := getFlagNonNegativeInt(cmd, "line-width")

		// ---------------------------------------------------------------

		fileSearchResult := getFlagString(cmd, "search-result")

		if fileSearchResult != "" {
			outputLog := opt.Verbose || opt.Log2File
			verbose := opt.Verbose

			bufferSizeS := getFlagString(cmd, "buffer-size")
			if bufferSizeS == "" {
				checkError(fmt.Errorf("value of buffer size. supported unit: K, M, G"))
			}

			bufferSize, err := ParseByteSize(bufferSizeS)
			if err != nil {
				checkError(fmt.Errorf("invalid value of buffer size. supported unit: K, M, G"))
			}

			buf := make([]byte, bufferSize)
			ncols := 20
			items := make([]string, ncols)

			fh, err := xopen.Ropen(fileSearchResult)
			checkError(err)

			// --------------------------------------------------
			if outputLog {
				log.Infof("loading index: %s", dbDir)
			}

			// info file
			fileInfo := filepath.Join(dbDir, FileInfo)
			info, err := readIndexInfo(fileInfo)
			if err != nil {
				checkError(fmt.Errorf("failed to read info file: %s", err))
			}
			if info.MainVersion != MainVersion {
				checkError(fmt.Errorf("index main versions do not match: %d (index) != %d (tool). please re-create the index", info.MainVersion, MainVersion))
			}

			// genomes.map file for mapping index to genome id
			m, err := readGenomeMapName2Idx(filepath.Join(dbDir, FileGenomeIndex))
			if err != nil {
				checkError(fmt.Errorf("failed to read genomes index mapping file: %s", err))
			}

			// genome readers
			if outputLog {
				log.Infof("creating the genome reader pool from %d genome batches", info.GenomeBatches)
			}
			readers := make(map[int]*genome.Reader, info.GenomeBatches)
			var wg sync.WaitGroup
			tokens := make(chan int, opt.NumCPUs)
			type b2r struct {
				batch int
				rdr   *genome.Reader
			}
			ch := make(chan b2r, opt.NumCPUs)
			done := make(chan int)
			go func() {
				for _b2r := range ch {
					readers[_b2r.batch] = _b2r.rdr
				}
				done <- 1
			}()
			for i := 0; i < info.GenomeBatches; i++ {
				tokens <- 1
				wg.Add(1)
				go func(i int) {
					fileGenomes := filepath.Join(dbDir, DirGenomes, batchDir(i), FileGenomes)
					rdr, err := genome.NewReader(fileGenomes)
					if err != nil {
						checkError(fmt.Errorf("failed to create genome reader: %s", err))
					}

					ch <- b2r{batch: i, rdr: rdr}

					wg.Done()
					<-tokens
				}(i)
			}
			wg.Wait()
			close(ch)
			<-done

			// --------------------------------------------------

			// output file handler
			outfh, gw, w, err := outStream(outFile, strings.HasSuffix(outFile, ".gz"), opt.CompressionLevel)
			checkError(err)
			defer func() {
				outfh.Flush()
				if gw != nil {
					gw.Close()
				}
				w.Close()
			}()

			if outputLog {
				log.Infof("extracting subsequences...")
			}

			scanner := bufio.NewScanner(fh)
			scanner.Buffer(buf, int(bufferSize))

			var query, qlen, hits, sgenome, sseqid, qcovGnm, cls, hsp, qcovHSP, alenHSP string
			var pident, gaps, qstart, qend, _sstart, _send, sstr, slen, evalue, bitscore string
			var sstart, send int

			var line string

			headerLine := true
			var batchIDAndRefIDs *[]uint64
			var ok bool
			// var fileGenome string
			var tSeq *genome.Genome
			var genomeBatch, genomeIdx int
			var rdr *genome.Reader

			var __end int
			fmt2 := " sgenome=%s sseqid=%s qcovGnm=%s cls=%s hsp=%s qcovHSP=%s alenHSP=%s " +
				"pident=%s gaps=%s qstart=%s qend=%s sstart=%s send=%s sstr=%s slen=%s evalue=%s bitscore=%s"

			n := 0

			for scanner.Scan() {
				line = strings.TrimRight(scanner.Text(), "\r\n")
				if line == "" {
					continue
				}
				if headerLine {
					headerLine = false
					continue
				}

				stringSplitNByByte(line, '\t', ncols, &items)
				if len(items) < ncols {
					checkError(fmt.Errorf("the input has only %d columns (<%d), please use output from 'lexicmap search'", ncols, len(items)))
				}

				query = items[0]
				_ = query
				qlen = items[1]
				_ = qlen
				hits = items[2]
				_ = hits

				sgenome = items[3]
				sseqid = items[4]
				qcovGnm = items[5]
				cls = items[6]
				hsp = items[7]
				qcovHSP = items[8]
				alenHSP = items[9]
				pident = items[10]
				gaps = items[11]
				qstart = items[12]
				qend = items[13]
				_sstart = items[14]
				_send = items[15]
				sstr = items[16]
				slen = items[17]
				evalue = items[18]
				bitscore = items[19]

				if batchIDAndRefIDs, ok = m[sgenome]; !ok {
					checkError(fmt.Errorf("reference name not found: %s", sgenome))
				}

				sstart, _ = strconv.Atoi(_sstart)
				send, _ = strconv.Atoi(_send)

				for _, batchIDAndRefID := range *batchIDAndRefIDs {
					genomeBatch = int(batchIDAndRefID >> BITS_GENOME_IDX)
					genomeIdx = int(batchIDAndRefID & MASK_GENOME_IDX)

					// fileGenome = filepath.Join(dbDir, DirGenomes, batchDir(genomeBatch), FileGenomes)
					// rdr, err = genome.NewReader(fileGenome)
					// if err != nil {
					// 	checkError(fmt.Errorf("failed to read genome data file: %s", err))
					// }
					rdr = readers[genomeBatch]

					tSeq, __end, err = rdr.SubSeq2(genomeIdx, []byte(sseqid), sstart-1, send-1)
					__end++ // returned end is 0-based.

					if __end != send {
						checkError(fmt.Errorf("unequal end position: %d != %d", send, __end))
					}

					if err == nil {
						break
					}
					// the sequence might not be in this genome chunk
				}
				if err != nil {
					checkError(fmt.Errorf("failed to read subsequence: %s:%s-%s:%s: %s", sseqid, _sstart, _send, sstr, err))
				}

				s, err := seq.NewSeq(seq.DNAredundant, tSeq.Seq)
				checkError(err)

				if sstr == "-" {
					s.RevComInplace()
				}

				fmt.Fprintf(outfh, ">%s:%s-%s:%s", sseqid, _sstart, _send, sstr)
				fmt.Fprintf(outfh, fmt2,
					sgenome, sseqid, qcovGnm, cls, hsp, qcovHSP, alenHSP,
					pident, gaps, qstart, qend, _sstart, _send, sstr, slen, evalue, bitscore,
				)
				fmt.Fprintln(outfh)

				outfh.Write(s.FormatSeq(lineWidth))
				outfh.WriteByte('\n')

				genome.RecycleGenome(tSeq)
				// checkError(rdr.Close())

				n++
				if verbose && ((n < 1024 && n&127 == 0) || n&1023 == 0) {
					fmt.Fprintf(os.Stderr, "\r%d subsequences extracted", n)
				}
			}
			if verbose {
				fmt.Fprintf(os.Stderr, "\r%d subsequences extracted", n)
				fmt.Fprintln(os.Stderr)
			}

			if outputLog {
				log.Infof("%d subsequences extracted", n)
			}

			for _, rdr := range readers {
				wg.Add(1)
				go func(rdr *genome.Reader) {
					checkError(rdr.Close())
					wg.Done()
				}(rdr)
			}
			wg.Wait()

			if outputLog {
				log.Info()
				log.Infof("elapsed time: %s", time.Since(timeStart0))
				log.Info()
			}

			return
		}

		// ---------------------------------------------------------------

		refname := getFlagString(cmd, "ref-name")
		if refname == "" {
			checkError(fmt.Errorf("flag -n/--ref-name needed"))
		}

		seqid := getFlagString(cmd, "seq-id")
		var concatenatedPositions bool
		if seqid == "" {
			concatenatedPositions = true
		}

		var reRegion = regexp.MustCompile(`\-?\d+:\-?\d+`)

		region := getFlagString(cmd, "region")
		if region == "" {
			checkError(fmt.Errorf("flag -r/--region needed"))
		}
		revcom := getFlagBool(cmd, "revcom")

		if !reRegion.MatchString(region) {
			checkError(fmt.Errorf(`invalid region: %s. type "lexicmap utils subseq -h" for more examples`, region))
		}
		var start, end int
		var err error

		r := strings.Split(region, ":")
		start, err = strconv.Atoi(r[0])
		checkError(err)
		end, err = strconv.Atoi(r[1])
		checkError(err)
		if start <= 0 || end <= 0 {
			checkError(fmt.Errorf("both begin and end position should not be <= 0"))
		}
		if start > end {
			checkError(fmt.Errorf("begin position should be < end position"))
		}

		// ---------------------------------------------------------------

		// info file
		fileInfo := filepath.Join(dbDir, FileInfo)
		info, err := readIndexInfo(fileInfo)
		if err != nil {
			checkError(fmt.Errorf("failed to read info file: %s", err))
		}
		if info.MainVersion != MainVersion {
			checkError(fmt.Errorf("index main versions do not match: %d (index) != %d (tool). please re-create the index", info.MainVersion, MainVersion))
		}

		// genomes.map file for mapping index to genome id
		m, err := readGenomeMapName2Idx(filepath.Join(dbDir, FileGenomeIndex))
		if err != nil {
			checkError(fmt.Errorf("failed to read genomes index mapping file: %s", err))
		}

		var batchIDAndRefIDs *[]uint64

		var ok bool
		if batchIDAndRefIDs, ok = m[refname]; !ok {
			checkError(fmt.Errorf("reference name not found: %s", refname))
		}

		var tSeq *genome.Genome
		var genomeBatch, genomeIdx int
		var rdr *genome.Reader

		var _end int

		for _, batchIDAndRefID := range *batchIDAndRefIDs {
			genomeBatch = int(batchIDAndRefID >> BITS_GENOME_IDX)
			genomeIdx = int(batchIDAndRefID & MASK_GENOME_IDX)

			fileGenome := filepath.Join(dbDir, DirGenomes, batchDir(genomeBatch), FileGenomes)
			rdr, err = genome.NewReader(fileGenome)
			if err != nil {
				checkError(fmt.Errorf("failed to read genome data file: %s", err))
			}

			if concatenatedPositions {
				tSeq, err = rdr.SubSeq(genomeIdx, start-1, end-1)
			} else {
				tSeq, _end, err = rdr.SubSeq2(genomeIdx, []byte(seqid), start-1, end-1)
				_end++ // returned end is 0-based.
			}
			if err == nil {
				break
				// checkError(fmt.Errorf("failed to read subsequence: %s", err))
			}
			// the sequence might not be in this genome chunk
		}
		if err != nil {
			checkError(fmt.Errorf("failed to read subsequence: %s:%s-%s: %s", refname, start, end, err))
		}

		end = _end // update end

		// output file handler
		outfh, gw, w, err := outStream(outFile, strings.HasSuffix(outFile, ".gz"), opt.CompressionLevel)
		checkError(err)
		defer func() {
			outfh.Flush()
			if gw != nil {
				gw.Close()
			}
			w.Close()
		}()

		s, err := seq.NewSeq(seq.DNAredundant, tSeq.Seq)
		checkError(err)

		strand := "+"
		if revcom {
			strand = "-"
			s.RevComInplace()
		}

		if concatenatedPositions {
			fmt.Fprintf(outfh, ">%s:%d-%d:%s\n", refname, start, end, strand)
		} else {
			fmt.Fprintf(outfh, ">%s:%d-%d:%s\n", seqid, start, end, strand)
		}
		outfh.Write(s.FormatSeq(lineWidth))
		outfh.WriteByte('\n')

		genome.RecycleGenome(tSeq)
		checkError(rdr.Close())
	},
}

func init() {
	utilsCmd.AddCommand(subseqCmd)

	subseqCmd.Flags().StringP("index", "d", "",
		formatFlagUsage(`Index directory created by "lexicmap index".`))

	subseqCmd.Flags().StringP("ref-name", "n", "",
		formatFlagUsage(`Reference name.`))

	subseqCmd.Flags().StringP("seq-id", "s", "",
		formatFlagUsage(`Sequence ID. If the value is empty, the positions in the region are treated as that in the concatenated sequence.`))

	subseqCmd.Flags().StringP("out-file", "o", "-",
		formatFlagUsage(`Out file, supports the ".gz" suffix ("-" for stdout).`))

	subseqCmd.Flags().StringP("region", "r", "",
		formatFlagUsage(`Region of the subsequence (1-based).`))

	subseqCmd.Flags().BoolP("revcom", "R", false,
		formatFlagUsage("Extract subsequence on the negative strand."))

	subseqCmd.Flags().IntP("line-width", "w", 60,
		formatFlagUsage("Line width of sequence (0 for no wrap)."))

	// -----

	subseqCmd.Flags().StringP("buffer-size", "b", "20M",
		formatFlagUsage(`Size of buffer, supported unit: K, M, G. You need increase the value when "bufio.Scanner: token too long" error reported`))

	subseqCmd.Flags().StringP("search-result", "f", "",
		formatFlagUsage(`Use search result file from "lexicmap search" as input. It can be "-" to accept filtered result from stdin`))

	subseqCmd.SetUsageTemplate(usageTemplate(""))
}
